{
  "metadata": {
    "repository": "https://github.com/b08x/omega-13",
    "generated_at": "2025-12-25T13:08:12.570617",
    "page_count": 10
  },
  "pages": [
    {
      "id": "introduction",
      "title": "Introduction to Omega-13",
      "content": "<details>\n<summary>Relevant source files</summary>\n\nThe following files were used as context for generating this wiki page:\n- [README.md](https://github.com/b08x/omega-13/blob/main/README.md)\n- [CHANGELOG.md](https://github.com/b08x/omega-13/blob/main/CHANGELOG.md)\n- [src/omega13/app.py](https://github.com/b08x/omega-13/blob/main/src/omega13/app.py)\n- [src/omega13/audio.py](https://github.com/b08x/omega-13/blob/main/src/omega13/audio.py)\n- [src/omega13/session.py](https://github.com/b08x/omega-13/blob/main/src/omega13/session.py)\n- [src/omega13/config.py](https://github.com/b08x/omega-13/blob/main/src/omega13/config.py)\n- [src/omega13/transcription.py](https://github.com/b08x/omega-13/blob/main/src/omega13/transcription.py)\n</details>\n\n# Introduction to Omega-13\n\n## 1. Introduction\nOmega-13 is a retroactive audio recording and transcription system designed for Linux environments. Its primary mechanism is the maintenance of a rolling 13-second in-memory buffer, allowing users to capture audio that occurred *before* the trigger event. The system functions as a TUI (Terminal User Interface) application that coordinates a JACK/PipeWire audio engine with a local AI transcription backend.\n\nSources: [README.md:#L1-L15](), [src/omega13/audio.py:#L12-L15]()\n\n## 2. System Architecture and Data Flow\n\n### 2.1 Audio Buffering Mechanism\nThe core of the system is the `AudioEngine`, which utilizes a NumPy ring buffer to store `float32` audio data. This buffer is constantly populated at the system's sample rate, maintaining exactly 13 seconds of history. When a recording is triggered, the engine \"stitches\" this pre-buffer (the past) with the active incoming stream (the present).\n\nSources: [src/omega13/audio.py:#L22-L45](), [README.md:#L125-L130]()\n\n### 2.2 Component Interaction\nThe application follows a modular structure where the `Omega13App` (Textual-based) acts as the central orchestrator. It manages the lifecycle of the `AudioEngine`, `SessionManager`, and `TranscriptionService`.\n\n| Component | Responsibility |\n| :--- | :--- |\n| `Omega13App` | UI rendering, hotkey handling, and global state management. |\n| `AudioEngine` | JACK client management, ring buffer maintenance, and WAV file writing. |\n| `SessionManager` | Lifecycle management of temporary and permanent recording sessions. |\n| `TranscriptionService` | Communication with the local Whisper HTTP API for audio-to-text conversion. |\n| `ConfigManager` | Persistence of user settings (hotkeys, server URLs, input ports). |\n\nSources: [src/omega13/app.py:#L45-L65](), [src/omega13/config.py:#L13-L30]()\n\n### 2.3 Transcription Pipeline\nThe transcription process is decoupled from the UI thread. It relies on a local Docker container running `whisper.cpp`. The application sends WAV files via HTTP POST to the `/inference` endpoint.\n\n```mermaid\nsequenceDiagram\n    participant U as User/Hotkey\n    participant A as Omega13App\n    participant E as AudioEngine\n    participant S as Session\n    participant T as TranscriptionService\n    participant W as Whisper Server (Docker)\n\n    U->>A: Trigger Capture (Hotkey)\n    A->>E: Start/Stop Recording\n    E->>S: Write .wav to /tmp\n    A->>T: Request Transcription(path)\n    T->>W: HTTP POST /inference\n    W-->>T: JSON Result (Text)\n    T->>A: Update UI & Clipboard\n```\n\nSources: [src/omega13/transcription.py:#L39-L65](), [README.md:#L125-L135]()\n\n## 3. Session and Data Management\n\n### 3.1 Deduplication Logic\nThe system implements a word-based overlap detection mechanism. This is a fucking curious structural choice to handle the \"retroactive\" nature of the recordings; if a user triggers multiple captures, the system attempts to find the longest suffix of previous text that matches the prefix of new text to prevent redundant sentences in the session log.\n\nSources: [src/omega13/session.py:#L1-L25](), [tests/test_deduplication.py:#L10-L30]()\n\n### 3.2 Configuration Schema\nThe `ConfigManager` handles the `config.json` located in `~/.config/omega13/`.\n\n| Field | Default Value | Description |\n| :--- | :--- | :--- |\n| `global_hotkey` | `<ctrl>+<alt>+space` | System-wide trigger for recording. |\n| `server_url` | `http://localhost:8080` | Endpoint for the Whisper AI container. |\n| `save_path` | `Path.cwd()` | Default directory for permanent session saves. |\n| `buffer_duration`| `13` | Seconds of audio kept in the ring buffer. |\n\nSources: [src/omega13/config.py:#L25-L45](), [src/omega13/audio.py:#L14]()\n\n## 4. Observed Operational Tendencies\nThe system exhibits a heavy dependency on external infrastructure that is not managed by the Python code itself. Specifically, while the app provides the TUI, the transcription fails silently or hangs if the Docker-based Whisper server is not manually started by the user (`docker compose up -d`). \n\nFurthermore, the \"Global Hotkey\" implementation on Wayland is not native; the system relies on a CLI \"poke\" mechanism (`omega13 --toggle`) where a second instance of the app reads a PID file and sends a signal to the primary instance. This reveals an architectural workaround for Wayland's security constraints regarding global key-logging.\n\nSources: [src/omega13/app.py:#L145-L165](), [README.md:#L85-L105]()\n\n## 5. Conclusion\nOmega-13 is structurally significant as a bridge between low-level audio processing (JACK/NumPy) and high-level AI inference. Its architecture prioritizes local privacy and retroactive capture, though it introduces operational complexity by requiring a coordinated environment of Docker containers, system-level hotkey redirects, and a JACK/PipeWire audio graph.\n\nSources: [README.md:#L140-L150](), [CHANGELOG.md:#L10-L30]()",
      "filePaths": [
        "README.md",
        "CHANGELOG.md"
      ],
      "importance": "high",
      "relatedPages": [
        "technical-architecture"
      ]
    },
    {
      "id": "getting-started",
      "title": "Getting Started & Installation",
      "content": "<details>\n<summary>Relevant source files</summary>\n\nThe following files were used as context for generating this wiki page:\n- [README.md](https://github.com/b08x/omega-13/blob/main/README.md)\n- [src/omega13/app.py](https://github.com/b08x/omega-13/blob/main/src/omega13/app.py)\n- [src/omega13/config.py](https://github.com/b08x/omega-13/blob/main/src/omega13/config.py)\n- [src/omega13/audio.py](https://github.com/b08x/omega-13/blob/main/src/omega13/audio.py)\n- [src/omega13/transcription.py](https://github.com/b08x/omega-13/blob/main/src/omega13/transcription.py)\n- [CHANGELOG.md](https://github.com/b08x/omega-13/blob/main/CHANGELOG.md)\n</details>\n\n# Getting Started & Installation\n\n## 1. Introduction\nOmega-13 is a retroactive audio recording system designed to capture audio from the past (defaulting to 13 seconds) and process it into transcriptions. The system architecture relies on a JACK/PipeWire audio backend, a Python-based Textual TUI, and a containerized Whisper inference server. Installation involves a multi-stage setup: deploying the inference container, installing the Python package, and configuring system-level global hotkeys to bypass Wayland security constraints.\n\nSources: [README.md](), [src/omega13/audio.py:#L14-L18]()\n\n## 2. System Architecture & Dependencies\nThe application functions as a bridge between real-time audio streams and asynchronous transcription services. It maintains a rolling NumPy ring buffer to facilitate \"retroactive\" capture.\n\n### Component Interaction Map\nThe following diagram illustrates the initialization and runtime flow:\n\n```mermaid\ngraph TD\n    A[User] -->|Launch| B[Omega13App]\n    B -->|Init| C[ConfigManager]\n    B -->|Start| D[AudioEngine]\n    B -->|Start| E[GlobalHotkeyListener]\n    D -->|Connect| F[JACK/PipeWire Server]\n    B -->|POST| G[Whisper Server Container]\n    G -->|JSON| B\n```\nThe system exhibits a somewhat rigid dependency on the Whisper container; while the UI remains functional without it, the core value proposition of \"capture to paste\" fails if the Docker/Podman service is not reachable at the configured `server_url`.\n\nSources: [src/omega13/app.py:#L100-L150](), [src/omega13/config.py:#L30-L45]()\n\n## 3. Installation & Deployment\n\n### Transcription Server Setup\nThe transcription backend must be deployed via Docker Compose. This environment requires NVIDIA CUDA support for performant inference.\n\n```bash\ndocker compose up -d\n```\n*Note: The system builds `whisper.cpp` from source within the container, leading to significant initial deployment latency.*\n\nSources: [README.md](), [CHANGELOG.md]()\n\n### Python Package Installation\nThe application is installed as a local Python package, which registers the `omega13` entry point.\n\n```bash\npip install .\n```\n\nSources: [README.md]()\n\n## 4. Configuration Mechanisms\nConfiguration is managed via `config.json`, typically located in `~/.config/omega13/`.\n\n| Parameter | Default Value | Description |\n| :--- | :--- | :--- |\n| `global_hotkey` | `<ctrl>+<alt>+space` | The key combo used to trigger capture. |\n| `server_url` | `http://localhost:8080` | Endpoint for the Whisper inference server. |\n| `buffer_duration` | 13 | Seconds of audio maintained in the ring buffer. |\n| `save_path` | `Path.cwd()` | Default location for permanent session storage. |\n\nSources: [src/omega13/config.py:#L25-L45](), [src/omega13/audio.py:#L14]()\n\n## 5. Global Hotkey Integration\nA critical structural constraint is the Wayland protocol's prevention of global key logging. Omega-13 resolves this by exposing a `--toggle` CLI flag. Users must manually map this flag to a system-level shortcut.\n\n### Toggle Logic Sequence\nThe `--toggle` flag communicates with a running instance via a PID file and Unix signals.\n\n```mermaid\nsequenceDiagram\n    participant OS as OS Shortcut Handler\n    participant CLI as omega13 --toggle\n    participant PID as .pid File\n    participant App as Running Omega13 Instance\n\n    OS->>CLI: Trigger Key Combo\n    CLI->>PID: Read Target PID\n    CLI->>App: Send SIGUSR1 / SIGUSR2\n    App->>App: Toggle Recording State\n```\nThis mechanism is a clever, if slightly annoying, workaround for modern Linux display server security. If the `.pid` file is missing or stale, the toggle fails silently from the user's perspective.\n\nSources: [src/omega13/app.py:#L135-L160](), [README.md]()\n\n## 6. Operational Flow: From Boot to Capture\nUpon startup, the `AudioEngine` initializes a `jack.Client`. It is a notable structural quirk that the app \"listens to nothing\" by default; users must interact with the Input Selector (`i`) to patch audio ports before the ring buffer begins filling.\n\n1. **Initialization**: `ConfigManager` loads settings; `AudioEngine` allocates the ring buffer.\n2. **Connection**: User maps JACK ports to `in_1` and `in_2`.\n3. **Buffering**: Audio flows into `self.ring_buffer` using a `write_ptr` that wraps at `ring_size`.\n4. **Capture**: Triggering the hotkey flushes the pre-buffer and starts active recording to a temporary `.wav` file.\n\nSources: [src/omega13/audio.py:#L30-L55](), [src/omega13/app.py:#L170-L190]()\n\n## Conclusion\nThe installation and setup of Omega-13 reveal a system that is highly modular yet operationally complex. The reliance on external JACK/PipeWire patching and a separate containerized inference engine creates multiple points of failure. However, the structural use of a PID-based signal toggle provides a robust solution for global interaction in restricted desktop environments. The system's significance lies in its ability to bridge low-level audio buffering with high-level AI inference through a unified TUI.",
      "filePaths": [
        "README.md",
        "pyproject.toml",
        "bootstrap.sh"
      ],
      "importance": "high",
      "relatedPages": [
        "configuration-guide",
        "containerization-whisper"
      ]
    },
    {
      "id": "technical-architecture",
      "title": "Technical Architecture",
      "content": "<details>\n<summary>Relevant source files</summary>\n\nThe following files were used as context for generating this wiki page:\n- [src/omega13/app.py](https://github.com/b08x/omega-13/blob/main/src/omega13/app.py)\n- [src/omega13/audio.py](https://github.com/b08x/omega-13/blob/main/src/omega13/audio.py)\n- [src/omega13/session.py](https://github.com/b08x/omega-13/blob/main/src/omega13/session.py)\n- [src/omega13/transcription.py](https://github.com/b08x/omega-13/blob/main/src/omega13/transcription.py)\n- [src/omega13/config.py](https://github.com/b08x/omega-13/blob/main/src/omega13/config.py)\n- [src/omega13/ui.py](https://github.com/b08x/omega-13/blob/main/src/omega13/ui.py)\n</details>\n\n# Technical Architecture\n\n## 1. Introduction\nOmega-13 is a retroactive audio recording system designed to capture audio from the past using a rolling ring buffer. The architecture is built around a central `Textual` application that orchestrates a JACK-based audio engine, a session management system for persistence, and an asynchronous transcription service. The system's primary mechanism is the \"capture\" event, which stitches together pre-recorded buffer data with real-time incoming streams to create a cohesive audio record of an event after it has already begun.\n\n## 2. Core Components and Mechanisms\n\n### Audio Engine and Ring Buffer\nThe `AudioEngine` serves as the low-level interface to the JACK audio server. It maintains a constant rolling `numpy` array (the ring buffer) that stores the last 13 seconds of audio. \n\n- **Mechanism**: The engine uses a `write_ptr` to continuously overwrite the oldest data in the `ring_buffer`.\n- **Capture Logic**: When recording starts, the engine captures the current state of the ring buffer (the \"past\") and begins streaming new data (the \"present\") into a `record_queue`.\n- **Inconsistency**: While the system claims to be \"retroactive,\" it depends entirely on the JACK server being active and the buffer being pre-filled. If the JACK server drops, the \"past\" is simply gone, a fragile dependency for a system named after a time-travel device.\n\nSources: [src/omega13/audio.py:#L17-L55](), [src/omega13/app.py:#L130-L145]()\n\n### Session Management and Persistence\nThe `Session` and `SessionManager` classes handle the lifecycle of recorded data. Sessions start in a temporary directory (`/tmp/omega13`) and are only moved to permanent storage upon explicit user command.\n\n| Component | Responsibility | Data Managed |\n| :--- | :--- | :--- |\n| `Session` | Individual session state | `.wav` files, `session.json` metadata, transcriptions |\n| `SessionManager` | Lifecycle & Cleanup | Directory creation, old session deletion, save path migration |\n\nSources: [src/omega13/session.py:#L55-L95](), [src/omega13/app.py:#L215-L230]()\n\n### Transcription Service\nTranscription is handled via an external HTTP API (`whisper-server`). The `TranscriptionService` manages the communication, including a word-based deduplication algorithm to handle overlapping audio segments.\n\nSources: [src/omega13/transcription.py:#L35-L65](), [src/omega13/session.py:#L110-L145]()\n\n## 3. Data Flow and Interactions\n\n### Audio Capture Sequence\nThe following diagram illustrates the transition from idle monitoring to active recording and subsequent transcription.\n\n```mermaid\nsequenceDiagram\n    participant U as User/Hotkey\n    participant A as Omega13App\n    participant E as AudioEngine\n    participant S as Session\n    participant T as TranscriptionService\n\n    U->>A: Trigger Hotkey\n    A->>E: start_recording()\n    E->>E: Flush Ring Buffer to Disk\n    E-->>A: Recording Active\n    U->>A: Trigger Hotkey (Stop)\n    A->>E: stop_recording()\n    E->>S: register_recording(path)\n    A->>T: transcribe_file(path)\n    T-->>A: TranscriptionResult\n    A->>S: add_transcription(text)\n```\nThe interaction shows a synchronous dependency on the `AudioEngine` to finalize files before the `TranscriptionService` can be invoked.\n\nSources: [src/omega13/app.py:#L150-L180](), [src/omega13/audio.py:#L60-L85]()\n\n### Transcription Deduplication Logic\nA significant structural feature is the overlap detection. When new text arrives, the system compares the prefix of the new text against the suffix of existing transcriptions to prevent repeated phrases.\n\n```mermaid\ngraph TD\n    A[New Transcription Text] --> B{History Exists?}\n    B -- No --> C[Append Directly]\n    B -- Yes --> D[Split into Words]\n    D --> E[Find Longest Suffix-Prefix Match]\n    E --> F[Strip Overlap]\n    F --> G[Append Unique Segment]\n```\nSources: [src/omega13/session.py:#L120-L145]()\n\n## 4. Configuration and Environment\nThe system relies on a JSON configuration file for persistent settings.\n\n| Field | Type | Default | Description |\n| :--- | :--- | :--- | :--- |\n| `global_hotkey` | string | `<ctrl>+<alt>+space` | System-wide trigger |\n| `server_url` | string | `http://localhost:8080` | Whisper API endpoint |\n| `save_path` | string | `CWD` | Permanent storage location |\n\nSources: [src/omega13/config.py:#L25-L45]()\n\n## 5. Structural Observations\nThe architecture exhibits a \"cooperative\" shutdown pattern. The `App` must signal the `AudioEngine` and `TranscriptionService` to stop, or the system hangs. This is a goddamn precarious setup where a single blocked thread in the transcription service\u2014which uses `requests` with a massive 600-second timeout\u2014can prevent the entire application from exiting cleanly. The system attempts to mitigate this with a `_shutdown_event`, but the reliance on external network calls for core functionality introduces significant latency risks.\n\nSources: [src/omega13/app.py:#L190-L210](), [src/omega13/transcription.py:#L45-L55]()\n\n## Conclusion\nThe Technical Architecture of Omega-13 is a specialized pipeline for temporal audio processing. Its structural significance lies in the integration of high-performance audio buffering (NumPy/JACK) with high-level UI orchestration (Textual). While the system effectively manages the transition from volatile buffers to persistent sessions, its stability is tightly coupled to the availability of the external transcription server and the responsiveness of the JACK audio backend.",
      "filePaths": [
        "src/omega13/app.py",
        "src/omega13/__init__.py"
      ],
      "importance": "high",
      "relatedPages": [
        "audio-engine-design",
        "transcription-pipeline"
      ]
    },
    {
      "id": "audio-engine-design",
      "title": "Audio Engine & Ring Buffer",
      "content": "<details>\n<summary>Relevant source files</summary>\n\nThe following files were used as context for generating this wiki page:\n- [src/omega13/audio.py](https://github.com/b08x/omega-13/blob/main/src/omega13/audio.py)\n- [src/omega13/app.py](https://github.com/b08x/omega-13/blob/main/src/omega13/app.py)\n- [src/omega13/session.py](https://github.com/b08x/omega-13/blob/main/src/omega13/session.py)\n- [src/omega13/ui.py](https://github.com/b08x/omega-13/blob/main/src/omega13/ui.py)\n- [src/omega13/transcription.py](https://github.com/b08x/omega-13/blob/main/src/omega13/transcription.py)\n- [README.md](https://github.com/b08x/omega-13/blob/main/README.md)\n</details>\n\n# Audio Engine & Ring Buffer\n\n## 1. Introduction\nThe Audio Engine and Ring Buffer constitute the core retroactive capture mechanism of Omega-13. The system operates as a JACK client that maintains a continuous, rolling in-memory buffer of audio data. Its primary role is to bridge the gap between real-time audio streams and persistent storage by allowing the system to \"look back\" in time\u2014specifically 13 seconds\u2014when a recording is triggered. This architecture shifts the recording paradigm from proactive (start-then-speak) to retroactive (speak-then-capture), relying on a circular NumPy array to manage temporal audio data without exhausting system memory.\n\n## 2. Detailed Sections\n\n### 2.1 Architecture and Data Flow\nThe `AudioEngine` class manages the lifecycle of audio data from the JACK input ports to the final `.wav` file. It initializes a `jack.Client` and registers input ports based on the configured channel count (Mono or Stereo).\n\nThe data flow follows a strict sequence:\n1. **Ingestion**: Audio is pulled from JACK input ports in the `process` callback.\n2. **Buffering**: Data is written to a circular `ring_buffer` (a NumPy array).\n3. **Triggering**: When `start_recording` is called, the engine reconstructs the \"past\" by stitching the two halves of the circular buffer together based on the current `write_ptr`.\n4. **Persistence**: A dedicated `_file_writer` thread handles the I/O operations to prevent blocking the real-time audio thread.\n\nSources: [src/omega13/audio.py:#L18-L60](), [src/omega13/audio.py:#L100-L130]()\n\n### 2.2 The Ring Buffer Mechanism\nThe ring buffer is the structural heart of the retroactive feature. It is sized based on the sample rate and a fixed `BUFFER_DURATION` (defaulting to 13 seconds). \n\n- **Circular Logic**: When the `write_ptr` reaches the end of the `ring_size`, it wraps back to index 0.\n- **State Tracking**: The `buffer_filled` flag indicates whether the buffer has performed at least one full revolution, determining if \"past\" data needs to be concatenated from the tail of the array.\n- **Inconsistency Note**: The system relies on a hardcoded `BUFFER_DURATION = 13`. While the code allows passing a different duration to the constructor, the UI and documentation are rigidly coupled to this \"13-second\" identity, creating a weirdly specific functional constraint that makes the \"Omega-13\" name both a feature and a structural limit.\n\nSources: [src/omega13/audio.py:#L14-L16](), [src/omega13/audio.py:#L73-L89]()\n\n### 2.3 Audio Activity Detection\nBefore a recording is committed, the system performs a pre-recording check for audio activity. This prevents the creation of \"ghost\" sessions containing only silence. If `has_audio_activity()` returns false, the UI blocks the capture and notifies the user. This is a classic example of a \"fail-fast\" mechanism designed to protect the session management logic from junk data.\n\nSources: [src/omega13/app.py:#L190-L205](), [README.md: Troubleshooting]()\n\n## 3. Mermaid Diagrams\n\n### 3.1 Audio Processing Sequence\nThe following diagram illustrates the interaction between the JACK server, the AudioEngine, and the persistent storage during a capture event.\n\n```mermaid\nsequenceDiagram\n    participant J as JACK Server\n    participant E as AudioEngine\n    participant B as Ring Buffer (NumPy)\n    participant W as File Writer Thread\n    participant S as Disk (Session Dir)\n\n    loop Every Process Cycle\n        J->>E: process(frames)\n        E->>B: _write_to_ring_buffer(data)\n    end\n\n    Note over E: User triggers Hotkey\n    E->>B: Reconstruct buffer (past_data)\n    activate E\n    E->>W: start(target_path, past_data)\n    deactivate E\n    \n    activate W\n    W->>S: Write .wav file\n    W-->>E: Recording Finished\n    deactivate W\n```\nSources: [src/omega13/audio.py:#L91-L130](), [src/omega13/app.py:#L180-L210]()\n\n## 4. Tables\n\n### Component Responsibilities\n| Component | Responsibility | Source |\n| :--- | :--- | :--- |\n| `AudioEngine` | Manages JACK client, port registration, and buffer logic. | [audio.py:#L18-L30]() |\n| `ring_buffer` | Circular NumPy array storing `float32` audio samples. | [audio.py:#L41-L43]() |\n| `VUMeter` | Reactive UI component displaying peak and dB levels. | [ui.py:#L13-L35]() |\n| `_file_writer` | Background thread for non-blocking disk I/O. | [audio.py:#L127-L130]() |\n| `SessionManager` | Handles the directory structure for saved audio. | [session.py:#L35-L55]() |\n\n### Data Model Attributes (SessionRecording)\n| Attribute | Type | Description |\n| :--- | :--- | :--- |\n| `filename` | `str` | Name of the generated `.wav` file. |\n| `duration_seconds`| `float` | Length of the captured audio. |\n| `channels` | `int` | Number of audio channels (1 for Mono, 2 for Stereo). |\n| `samplerate` | `int` | Frequency of the audio (e.g., 44100, 48000). |\n\nSources: [src/omega13/session.py:#L5-L20]()\n\n## 5. Code Snippets\n\n### Circular Buffer Write Logic\nThis snippet demonstrates the wrap-around logic used to maintain the 13-second window. It's a straightforward implementation, but the split-write logic (`part1`/`part2`) is critical for ensuring no data is dropped during the wrap-around.\n\n```python\n# src/omega13/audio.py:#L73-L85\ndef _write_to_ring_buffer(self, data: np.ndarray, frames: int) -> None:\n    remaining_space = self.ring_size - self.write_ptr\n    if frames <= remaining_space:\n        self.ring_buffer[self.write_ptr : self.write_ptr + frames] = data\n        self.write_ptr += frames\n    else:\n        part1 = remaining_space\n        part2 = frames - remaining_space\n        self.ring_buffer[self.write_ptr : self.write_ptr + part1] = data[:part1]\n        self.ring_buffer[0 : part2] = data[part1:]\n        self.write_ptr = part2\n        self.buffer_filled = True\n```\n\n## 6. Conclusion\nThe Audio Engine and Ring Buffer provide a robust, low-latency foundation for retroactive recording. By offloading file I/O to separate threads and utilizing NumPy for efficient memory management, the system maintains high performance even while constantly \"listening.\" The structural reliance on the JACK/PipeWire ecosystem ensures professional-grade audio handling, though the rigid 13-second buffer duration remains a defining, if somewhat inflexible, characteristic of the architecture.\n\nSources: [src/omega13/audio.py](), [src/omega13/app.py](), [README.md]()",
      "filePaths": [
        "src/omega13/audio.py"
      ],
      "importance": "high",
      "relatedPages": [
        "technical-architecture"
      ]
    },
    {
      "id": "session-management",
      "title": "Session & Data Management",
      "content": "<details>\n<summary>Relevant source files</summary>\n\nThe following files were used as context for generating this wiki page:\n- [src/omega13/session.py](https://github.com/b08x/omega-13/blob/main/src/omega13/session.py)\n- [tests/test_deduplication.py](https://github.com/b08x/omega-13/blob/main/tests/test_deduplication.py)\n- [tests/test_incremental_save.py](https://github.com/b08x/omega-13/blob/main/tests/test_incremental_save.py)\n- [src/omega13/app.py](https://github.com/b08x/omega-13/blob/main/src/omega13/app.py)\n- [CHANGELOG.md](https://github.com/b08x/omega-13/blob/main/CHANGELOG.md)\n</details>\n\n# Session & Data Management\n\n## Introduction\nSession & Data Management in Omega-13 coordinates the lifecycle of audio recordings and their associated metadata. It acts as a bridge between volatile temporary storage (typically `/tmp/omega13`) and permanent user-defined directories. The system relies on a sequential registration of audio files and a word-based deduplication mechanism for transcriptions, ensuring that incremental updates do not result in redundant data.\n\nSources: `[src/omega13/session.py:#L1-L15]`, `[src/omega13/app.py:#L1-L20]`\n\n## Architecture and Data Flow\nThe architecture is centered around the `SessionManager`, which orchestrates the `Session` objects. Each session maintains its own directory structure for raw audio and transcription text.\n\n### Component Responsibilities\n| Component | Responsibility | Key Methods |\n| :--- | :--- | :--- |\n| `SessionManager` | Manages session creation, persistence, and cleanup of old temporary files. | `create_session`, `save_session` |\n| `Session` | Handles the internal directory structure, metadata serialization, and transcription deduplication. | `register_recording`, `add_transcription`, `save_metadata` |\n| `SessionRecording` | Data class representing a single WAV file's metadata. | `to_dict`, `from_dict` |\n\nSources: `[src/omega13/session.py:#L25-L150]`\n\n### Session Lifecycle Flow\nThe following diagram illustrates the transition from a volatile temporary session to a persisted state.\n\n```mermaid\ngraph TD\n    A[App Startup] --> B[SessionManager.create_session]\n    B --> C[Create /tmp/omega13/session_ID]\n    C --> D[Register Recordings/Transcriptions]\n    D --> E{User Triggers Save?}\n    E -- Yes --> F[shutil.copy2 to Permanent Location]\n    F --> G[Update session.json 'saved' status]\n    E -- No --> H[Auto-cleanup on next launch]\n```\n\nSources: `[src/omega13/session.py:#L100-L130]`, `[src/omega13/app.py:#L15-L25]`\n\n## Transcription Deduplication Mechanism\nA critical, albeit somewhat finicky, feature is the word-based suffix-prefix matching used when adding transcriptions. Because the transcription service may return overlapping segments of audio, the `Session` class attempts to find the longest overlapping word sequence between the new text and the last five historical entries.\n\nIf the system finds that the start of the new text matches the end of the existing history, it strips the overlap. This prevents the \"goddamn double-talk\" effect in the final logs.\n\n```python\n# src/omega13/session.py\nhistory_context = \" \".join(self.transcriptions[-5:]).split()\nnew_words = new_text.split()\n\nmax_overlap = 0\nmax_search = min(len(history_context), len(new_words))\n\nfor i in range(1, max_search + 1):\n    if history_context[-i:] == new_words[:i]:\n        max_overlap = i\n```\n\nSources: `[src/omega13/session.py:#L160-L185]`, `[tests/test_deduplication.py]`\n\n## Data Persistence and Synchronization\nThe system implements an incremental sync pattern. Once a session is marked as `saved`, any subsequent recordings or transcriptions are automatically mirrored to the permanent storage location via `_sync_to_save_location`.\n\n### Metadata Structure (`session.json`)\n| Field | Type | Description |\n| :--- | :--- | :--- |\n| `session_id` | String | Unique ID: `session_YYYYMMDD_HHMMSS_UUID` |\n| `recordings` | List[Dict] | List of serialized `SessionRecording` objects |\n| `transcriptions` | List[String] | Deduplicated transcription segments |\n| `saved` | Boolean | Persistence status |\n\nSources: `[src/omega13/session.py:#L190-L210]`, `[tests/test_incremental_save.py]`\n\n### The Persistence Sequence\nThe interaction between the manager and the active session during a save operation:\n\n```mermaid\nsequenceDiagram\n    participant U as User/UI\n    participant M as SessionManager\n    participant S as Session\n    participant FS as FileSystem\n\n    U->+M: save_session(destination)\n    M->+S: Set save_location & saved=True\n    S->S: save_metadata()\n    S->FS: Write session.json to temp_dir\n    M->FS: shutil.copy2(temp_dir, destination)\n    S->-M: Return Success\n    M->-U: Notify User\n```\n\nSources: `[src/omega13/session.py:#L110-L145]`, `[src/omega13/app.py:#L30-L45]`\n\n## Structural Observations\nThe system exhibits a tight coupling between the `Session` and the filesystem. A `Session` object cannot exist without creating physical directories (`recordings/` and `transcriptions/`) immediately upon instantiation. While this ensures data integrity, it means the mere act of \"thinking\" about a session litters the `/tmp` directory. Furthermore, the deduplication logic relies on a hardcoded \"last 5 entries\" context, which is a structural heuristic that might fail if transcription segments are exceptionally long or short.\n\nSources: `[src/omega13/session.py:#L70-L85]`, `[src/omega13/session.py:#L175]`\n\n## Conclusion\nSession & Data Management in Omega-13 provides a robust, if opinionated, pipeline for retroactive audio storage. By utilizing a dual-stage storage strategy and word-based deduplication, it maintains a clean record of events despite the potentially chaotic nature of streaming audio transcriptions. Its structural significance lies in its ability to transform transient audio buffers into a structured, searchable historical archive.\n\nSources: `[src/omega13/session.py]`, `[CHANGELOG.md]`",
      "filePaths": [
        "src/omega13/session.py",
        "tests/test_deduplication.py",
        "tests/test_incremental_save.py"
      ],
      "importance": "medium",
      "relatedPages": [
        "transcription-pipeline"
      ]
    },
    {
      "id": "transcription-pipeline",
      "title": "Transcription Pipeline",
      "content": "<details>\n<summary>Relevant source files</summary>\n\nThe following files were used as context for generating this wiki page:\n- [src/omega13/transcription.py](https://github.com/b08x/omega-13/blob/main/src/omega13/transcription.py)\n- [src/omega13/app.py](https://github.com/b08x/omega-13/blob/main/src/omega13/app.py)\n- [src/omega13/session.py](https://github.com/b08x/omega-13/blob/main/src/omega13/session.py)\n- [src/omega13/ui.py](https://github.com/b08x/omega-13/blob/main/src/omega13/ui.py)\n- [src/omega13/config.py](https://github.com/b08x/omega-13/blob/main/src/omega13/config.py)\n- [README.md](https://github.com/b08x/omega-13/blob/main/README.md)\n</details>\n\n# Transcription Pipeline\n\n## Introduction\nThe Transcription Pipeline in Omega-13 is a decoupled, asynchronous mechanism designed to convert captured audio buffers into text via an external HTTP API. It acts as the bridge between the `AudioEngine`'s output and the user's clipboard or session storage. The pipeline is characterized by its reliance on a local Docker-based `whisper-server` and a reactive UI that tracks processing states.\n\nSources: [src/omega13/transcription.py](), [README.md]()\n\n## Architectural Flow\nThe pipeline operates by sending `.wav` files to a Whisper inference endpoint. The `TranscriptionService` manages the lifecycle of these requests, including error handling and progress reporting.\n\n### Data Flow Mechanism\n1. **Trigger**: A recording is finalized in `Omega13App`.\n2. **Dispatch**: The app calls `transcribe_async`, spawning a non-daemon thread.\n3. **Transmission**: The audio file is POSTed to the configured `server_url`.\n4. **Deduplication**: Upon receipt of text, the `Session` manager performs word-based suffix-prefix matching to prevent redundant text segments in the session history.\n5. **Output**: Text is simultaneously routed to the `TranscriptionDisplay` UI, the system clipboard (if enabled), and the session's metadata.\n\nSources: [src/omega13/transcription.py:#L66-L85](), [src/omega13/session.py:#L25-L60]()\n\n### Sequence of Operations\nThe following diagram illustrates the interaction between the UI, the service, and the external inference server.\n\n```mermaid\nsequenceDiagram\n    participant App as Omega13App\n    participant TS as TranscriptionService\n    participant WS as whisper-server (Docker)\n    participant SM as SessionManager\n\n    App->+TS: transcribe_async(audio_path)\n    TS->+WS: POST /inference (audio file)\n    WS-->>-TS: 200 OK (JSON result)\n    TS->>App: on_complete(result)\n    App->>SM: add_transcription(text)\n    SM->>SM: _sync_to_save_location()\n    App->>App: update UI & Clipboard\n    deactivate TS\n```\nSources: [src/omega13/transcription.py](), [src/omega13/app.py:#L175-L200]()\n\n## Component Specifications\n\n### TranscriptionService Configuration\nThe service is highly dependent on the `ConfigManager` for its network identity and operational constraints.\n\n| Parameter | Default Value | Description |\n| :--- | :--- | :--- |\n| `server_url` | `http://localhost:8080` | The base URL for the whisper-server. |\n| `inference_path` | `/inference` | The specific endpoint for transcription. |\n| `timeout` | 600 seconds | Maximum time allowed for a single request. |\n| `copy_to_clipboard` | `True` (Config) | Global toggle for automated clipboard injection. |\n\nSources: [src/omega13/config.py:#L30-L40](), [src/omega13/transcription.py:#L38-L50]()\n\n### State Management\nThe pipeline uses an `Enum` to track the lifecycle of a transcription task, which is reflected in the UI's `TranscriptionDisplay`.\n\n```python\nclass TranscriptionStatus(Enum):\n    IDLE = \"idle\"\n    LOADING_MODEL = \"loading_model\"\n    PROCESSING = \"processing\"\n    COMPLETED = \"completed\"\n    ERROR = \"error\"\n```\nSources: [src/omega13/transcription.py:#L21-L26]()\n\n## Observed Structural Inconsistencies\nThe system exhibits a few \"interesting\" architectural choices. For instance, the `TranscriptionService` is instantiated with a `daemon=False` thread in `transcribe_async`, yet the `Omega13App` attempts a \"graceful shutdown\" that must cooperatively signal these threads to stop. If the `whisper-server` hangs, the app's shutdown logic might be fucked if the timeout isn't strictly enforced during the join.\n\nFurthermore, the deduplication logic in `session.py` relies on a word-based suffix match of the last 5 transcriptions. This assumes that subsequent recordings will always overlap in a linear, predictable fashion, which is a fragile goddamn way to handle continuous audio streams if the user triggers captures rapidly.\n\nSources: [src/omega13/transcription.py:#L81](), [src/omega13/session.py:#L45-L55](), [src/omega13/app.py:#L135-L150]()\n\n## Session Integration and Deduplication\nThe `Session` class ensures that transcriptions are not just appended but merged intelligently.\n\n```python\n# Suffix-prefix overlap detection\nhistory_context = \" \".join(self.transcriptions[-5:]).split()\nnew_words = new_text.split()\nmax_overlap = 0\nfor i in range(1, min(len(history_context), len(new_words)) + 1):\n    if history_context[-i:] == new_words[:i]:\n        max_overlap = i\nunique_segment = \" \".join(new_words[max_overlap:])\n```\nSources: [src/omega13/session.py:#L48-L58]()\n\n## Conclusion\nThe Transcription Pipeline is a reactive, network-dependent subsystem. Its structural significance lies in its ability to offload heavy compute (Whisper inference) to a separate containerized environment while maintaining a tight feedback loop with the Textual UI. While the deduplication and thread management logic introduce potential points of failure, the pipeline successfully abstracts the complexity of audio-to-text conversion from the core `AudioEngine`.",
      "filePaths": [
        "src/omega13/transcription.py",
        "src/omega13/clipboard.py"
      ],
      "importance": "high",
      "relatedPages": [
        "containerization-whisper",
        "session-management"
      ]
    },
    {
      "id": "hotkey-handling",
      "title": "Global Hotkey & Notifications",
      "content": "<details>\n<summary>Relevant source files</summary>\n\nThe following files were used as context for generating this wiki page:\n- [src/omega13/hotkeys.py](https://github.com/b08x/omega-13/blob/main/src/omega13/hotkeys.py)\n- [src/omega13/notifications.py](https://github.com/b08x/omega-13/blob/main/src/omega13/notifications.py)\n- [src/omega13/app.py](https://github.com/b08x/omega-13/blob/main/src/omega13/app.py)\n- [src/omega13/config.py](https://github.com/b08x/omega-13/blob/main/src/omega13/config.py)\n- [README.md](https://github.com/b08x/omega-13/blob/main/README.md)\n</details>\n\n# Global Hotkey & Notifications\n\n## Introduction\nThe \"Global Hotkey & Notifications\" system provides the primary interface for asynchronous interaction with the Omega-13 recording engine. It bridges the gap between the terminal-based UI and the system environment, allowing users to trigger recording state changes while the application is unfocused. This mechanism relies on a combination of local event listening and system-level signal handling to overcome environmental constraints like Wayland's security model.\n\nSources: [src/omega13/app.py:#L120-L135](), [README.md:#L85-L105]()\n\n## Global Hotkey Architecture\nThe hotkey system is designed around the `GlobalHotkeyListener` class, which utilizes the `pynput` library to monitor keyboard events. A significant structural constraint is observed in the implementation: while the application attempts to listen for global keys, it explicitly acknowledges that Wayland prevents applications from \"spying\" on global keystrokes. This creates a functional contradiction where the internal listener may fail, necessitating an external \"poke\" via a CLI toggle command.\n\n### Key Resolution and Normalization\nThe system performs normalization on hotkey strings to ensure compatibility between configuration formats and `pynput` requirements.\n\n| Component | Responsibility |\n| :--- | :--- |\n| `_resolve_hotkey` | Strips brackets and maps aliases like \"enter\" or \"space\" to `<enter>` and `<space>`. |\n| `ConfigManager` | Provides the default hotkey string: `<ctrl>+<alt>+space`. |\n| `pynput` | Optional dependency; if missing, global hotkeys are disabled. |\n\nSources: [src/omega13/hotkeys.py:#L15-L55](), [src/omega13/config.py:#L30-L35]()\n\n### Interaction Logic\nThe following diagram illustrates the flow from a hotkey trigger to the recording state change.\n\n```mermaid\nsequenceDiagram\n    participant U as User\n    participant H as GlobalHotkeyListener\n    participant A as Omega13App\n    participant E as AudioEngine\n\n    U->>H: Presses Hotkey (e.g., Ctrl+Alt+Space)\n    activate H\n    H->>A: call_from_thread(action_toggle_record)\n    deactivate H\n    activate A\n    A->>E: toggle_record()\n    A->>A: update_ui_status()\n    A-->>U: Desktop Notification (Success/Failure)\n    deactivate A\n```\nNote: The use of `call_from_thread` is a critical structural requirement because the hotkey listener runs in a separate thread from the Textual UI loop.\n\nSources: [src/omega13/app.py:#L125-L135](), [src/omega13/hotkeys.py:#L65-L75]()\n\n## Notification Mechanism\nDesktop notifications are handled by the `DesktopNotifier` class. This component is a thin wrapper around the system's `notify-send` utility. It is functionally dependent on the existence of this binary in the user's PATH; if `shutil.which(\"notify-send\")` returns None, the system silently fails to notify, which is a shitty but common pattern for Linux desktop integration.\n\n### Notification Attributes\nSources: [src/omega13/notifications.py:#L10-L35]()\n\n| Parameter | Type | Default | Description |\n| :--- | :--- | :--- | :--- |\n| `title` | String | N/A | The summary of the event. |\n| `message` | String | N/A | The body text. |\n| `urgency` | String | \"normal\" | Maps to `notify-send -u`. |\n| `timeout` | Integer | 2000 | Expiration in milliseconds. |\n\n## Structural Inconsistencies: The Wayland Problem\nThe architecture reveals a desperate workaround for modern Linux display servers. Because the internal `GlobalHotkeyListener` is often neutered by Wayland's security protocols, the application implements a secondary signaling path using `SIGUSR1`.\n\n1.  **Internal Path:** `pynput` -> `action_toggle_record`.\n2.  **External Path:** `omega13 --toggle` -> Reads PID file -> Sends `SIGUSR1` to process -> `action_toggle_record`.\n\nThis redundancy highlights a system that cannot trust its own primary input mechanism. The PID file management in `app.py` exists solely to facilitate this external \"poke\" because the global hotkey implementation is structurally unreliable in non-X11 environments.\n\nSources: [src/omega13/app.py:#L105-L115](), [src/omega13/app.py:#L190-L210](), [README.md:#L90-L100]()\n\n```python\n# src/omega13/app.py - External Toggle Support\nif hasattr(signal, \"SIGUSR1\"):\n    signal.signal(signal.SIGUSR1, lambda s, f: self.call_later(self.action_toggle_record))\n```\n\n## Configuration and Initialization\nThe `ConfigManager` determines if notifications are even attempted via `get_desktop_notifications_enabled()`. During the `on_mount` phase of the application, the hotkey listener is initialized only after the UI components are ready, ensuring that the callback has a valid application state to manipulate.\n\nSources: [src/omega13/config.py:#L75-L80](), [src/omega13/app.py:#L120-L130]()\n\n## Conclusion\nThe Global Hotkey & Notifications system is the primary sensory and feedback loop for the user. Its structural significance lies in its dual-path execution\u2014maintaining an internal listener for legacy environments while providing a signal-based API for modern, restricted environments. This complexity is the direct result of the application's need to operate as a background service while maintaining a TUI-based frontend.",
      "filePaths": [
        "src/omega13/hotkeys.py",
        "src/omega13/notifications.py"
      ],
      "importance": "medium",
      "relatedPages": [
        "configuration-guide"
      ]
    },
    {
      "id": "tui-components",
      "title": "TUI Components & UX",
      "content": "<details>\n<summary>Relevant source files</summary>\n\nThe following files were used as context for generating this wiki page:\n- [src/omega13/app.py](https://github.com/b08x/omega-13/blob/main/src/omega13/app.py)\n- [src/omega13/ui.py](https://github.com/b08x/omega-13/blob/main/src/omega13/ui.py)\n- [src/omega13/config.py](https://github.com/b08x/omega-13/blob/main/src/omega13/config.py)\n- [src/omega13/session.py](https://github.com/b08x/omega-13/blob/main/src/omega13/session.py)\n- [README.md](https://github.com/b08x/omega-13/blob/main/README.md)\n- [CHANGELOG.md](https://github.com/b08x/omega-13/blob/main/CHANGELOG.md)\n</details>\n\n# TUI Components & UX\n\n## Introduction\nThe \"TUI Components & UX\" of Omega-13 is a Textual-based interface designed to facilitate retroactive audio capture and transcription management. The system operates as a terminal-resident dashboard that coordinates between a JACK-based audio engine, a local transcription server, and a session-based filesystem. Its primary role is to provide real-time visual feedback of audio levels (VU meters) and transcription status while managing user configuration through modal screens.\n\nSources: [src/omega13/app.py](), [src/omega13/ui.py]()\n\n## Core Layout and Architecture\nThe interface is structured using a `Horizontal` layout divided into a control pane and a transcription pane.\n\n### Left Pane: Audio & Transcription Controls\nThe left pane contains the primary status indicators and system controls.\n- **Audio Controls**: Displays the application title, recording status, session information, and buffer fill percentage.\n- **VU Meters**: Provides real-time visual feedback for up to two audio channels.\n- **Transcription Controls**: Contains the status label and a checkbox for clipboard synchronization.\n\n### Right Pane: Transcription Display\nThe right pane is dedicated to the `TranscriptionDisplay` widget, which utilizes a `RichLog` to show formatted text output from the transcription service.\n\nSources: [src/omega13/app.py:#L40-L100](), [src/omega13/ui.py:#L50-L70]()\n\n## Component Interaction Flow\nThe TUI acts as the central coordinator. When a global hotkey is triggered, the `Omega13App` updates the UI state, which in turn reflects the underlying audio engine's transition from \"Idle\" to \"Recording.\"\n\n```mermaid\ngraph TD\n    A[Global Hotkey / CLI Toggle] --> B[Omega13App]\n    B --> C{State Change}\n    C -->|Start| D[Update status-bar to Recording]\n    C -->|Stop| E[Update status-bar to Idle]\n    E --> F[Trigger Transcription Service]\n    F --> G[Update TranscriptionDisplay]\n```\nNote: The UI relies on `reactive` attributes to update VU meters and status labels without manual refresh calls.\n\nSources: [src/omega13/app.py:#L170-L200](), [src/omega13/ui.py:#L15-L25]()\n\n## Key UI Components\n\n| Component | Responsibility | Data Source |\n| :--- | :--- | :--- |\n| `VUMeter` | Visualizes peak and dB levels for audio channels. | `AudioEngine.peaks` |\n| `TranscriptionDisplay` | Manages the transcription log and status styles. | `TranscriptionService` |\n| `InputSelectionScreen` | Modal for JACK port mapping (Mono/Stereo). | `jack.Client` |\n| `DirectorySelectionScreen` | Filesystem navigation for saving sessions. | `ConfigManager` |\n\nSources: [src/omega13/ui.py:#L13-L45](), [src/omega13/ui.py:#L120-L160]()\n\n## Structural Observations & Inconsistencies\nThe system exhibits a somewhat rigid dependency between the UI and the underlying services. For instance, the `TranscriptionDisplay` widget is manually injected with a `ConfigManager` and then proceeds to query the parent app for its own status labels and checkboxes (`self.app.query_one`). This creates a circular-adjacent dependency where the child widget must \"know\" the ID structure of the main application layout to function. \n\nFurthermore, while the system supports \"Mono\" mode, the UI layout for `meters` is hardcoded to yield two labels and two meters in the `compose` method, only hiding the second meter via CSS `display` properties later. It\u2019s a bit of a hacky way to handle dynamic hardware configurations, but it ensures the layout remains stable.\n\nSources: [src/omega13/app.py:#L120-L140](), [src/omega13/ui.py:#L80-L95]()\n\n## Sequence: Session Saving Process\nThe following diagram illustrates the interaction when a user initiates a session save.\n\n```sequenceDiagram\n    participant U as User (Key 'S')\n    participant A as Omega13App\n    participant S as SavePromptScreen\n    participant SM as SessionManager\n    participant D as DirectorySelectionScreen\n\n    U->>A: Press 'S'\n    A->>S: Push Screen\n    S->>D: Request Directory\n    D-->>S: Return Path\n    S->>SM: save_session(path)\n    SM->>SM: _sync_to_save_location()\n    A->>A: _update_session_status()\n```\nSources: [src/omega13/app.py:#L210-L230](), [src/omega13/session.py:#L45-L55]()\n\n## Configuration Management\nThe UI state is heavily driven by `config.json`.\n- **Hotkeys**: The help text in the TUI is dynamically updated based on the `global_hotkey` setting in the config.\n- **Clipboard**: The \"Copy to clipboard\" checkbox state is persisted across sessions via the `ConfigManager`.\n\n```python\n# src/omega13/app.py\nhotkey = self.config_manager.get_global_hotkey()\nformatted_hotkey = hotkey.replace(\"<\", \"\").replace(\">\", \"\").replace(\"+\", \" + \").title()\nhelp_text = self.query_one(\"#help-text\", Static)\nhelp_text.update(f\"\\n[dim]{formatted_hotkey} to Capture | I Inputs | S Save | T Transcribe[/dim]\")\n```\nSources: [src/omega13/config.py](), [src/omega13/app.py:#L150-L165]()\n\n## Conclusion\nThe TUI Components & UX of Omega-13 provide a functional, albeit tightly coupled, interface for audio management. The system's structural significance lies in its ability to abstract complex JACK routing and asynchronous transcription tasks into a simplified set of visual statuses and modal dialogues. The reliance on `Textual`'s reactive framework allows the system to maintain high-frequency VU meter updates while handling potentially slow network requests for transcription.",
      "filePaths": [
        "src/omega13/ui.py",
        "src/omega13/app.py"
      ],
      "importance": "medium",
      "relatedPages": [
        "technical-architecture"
      ]
    },
    {
      "id": "containerization-whisper",
      "title": "Whisper Server Infrastructure",
      "content": "<details>\n<summary>Relevant source files</summary>\n\nThe following files were used as context for generating this wiki page:\n- [compose.yml](https://github.com/b08x/omega-13/blob/main/compose.yml)\n- [src/omega13/transcription.py](https://github.com/b08x/omega-13/blob/main/src/omega13/transcription.py)\n- [src/omega13/app.py](https://github.com/b08x/omega-13/blob/main/src/omega13/app.py)\n- [src/omega13/config.py](https://github.com/b08x/omega-13/blob/main/src/omega13/config.py)\n- [README.md](https://github.com/b08x/omega-13/blob/main/README.md)\n- [CHANGELOG.md](https://github.com/b08x/omega-13/blob/main/CHANGELOG.md)\n</details>\n\n# Whisper Server Infrastructure\n\n### 1. Introduction\nThe Whisper Server Infrastructure serves as the decoupled transcription engine for the Omega-13 retroactive audio recorder. It is architected as a containerized HTTP service that processes WAV audio files into text using the `whisper.cpp` framework. The system relies on a request-response pattern where the Python-based frontend acts as a client, offloading computationally intensive inference to a CUDA-enabled backend. This separation allows the core application to maintain a lightweight TUI while delegating heavy lifting to a specialized environment.\n\nSources: [README.md](), [src/omega13/transcription.py:#L1-L15]()\n\n### 2. Containerized Deployment and Environment\nThe infrastructure is defined via a Docker Compose configuration that targets NVIDIA GPU hardware. The service is built from a `Containerfile` and specifically optimized for CUDA execution to handle large-scale models like `ggml-large-v3-turbo`.\n\n#### Service Configuration\n| Parameter | Value/Source | Purpose |\n| :--- | :--- | :--- |\n| Image | `whisper-server-cuda:latest` | Specialized CUDA build of whisper.cpp |\n| Port | `8080:8080` | REST API endpoint |\n| Model Path | `/app/models/ggml-large-v3-turbo-q5_0.bin` | High-performance quantized model |\n| GPU Access | `nvidia.com/gpu=all` | Hardware acceleration requirement |\n\nThe container mounts host directories for models and recordings, utilizing `:Z` flags for SELinux compatibility. Curiously, while the system is designed for automation, it requires a manual `docker compose up -d` step before the main application can function correctly, creating a brittle dependency if the container fails to initialize.\n\nSources: [compose.yml:#L4-L60](), [README.md]()\n\n### 3. Communication Protocol and Data Flow\nThe interaction between the Omega-13 application and the Whisper server follows a strict HTTP POST sequence. The `TranscriptionService` class manages this lifecycle, including health checks and asynchronous request handling.\n\n#### Transcription Lifecycle Sequence\nThe following diagram illustrates the flow from a finished recording to a returned transcript.\n\n```mermaid\nsequenceDiagram\n    participant A as Omega13App\n    participant S as TranscriptionService\n    participant W as Whisper Server (Container)\n    \n    A->>S: transcribe_async(audio_path)\n    activate S\n    S->>W: GET / (Health Check)\n    W-->>S: 200 OK\n    S->>W: POST /inference (Multipart WAV)\n    activate W\n    Note over W: Running Inference (CUDA)\n    W-->>S: 200 OK (JSON Response)\n    deactivate W\n    S->>A: callback(TranscriptionResult)\n    deactivate S\n    A->>A: Copy to Clipboard (Optional)\n```\nThe implementation includes a \"cooperative shutdown\" mechanism. If the application initiates a shutdown while a transcription is in progress, the service attempts to truncate the request timeout to 3.0 seconds to prevent the process from hanging. It's a bit of a shit-show if the server is halfway through a large file; the system just cuts the cord.\n\nSources: [src/omega13/transcription.py:#L55-L95](), [src/omega13/app.py:#L140-L160]()\n\n### 4. Configuration and Integration\nThe application tracks the server's state through a reactive UI component. The configuration is managed via `config.json`, which stores the server URL and model preferences.\n\n#### Key Configuration Attributes\n- **Server URL:** Defaulted to `http://localhost:8080`.\n- **Auto-transcribe:** Boolean flag to trigger transcription immediately after recording stops.\n- **Model Size:** Configurable, though the `compose.yml` hardcodes the turbo model.\n\nSources: [src/omega13/config.py:#L30-L45](), [src/omega13/ui.py:#L45-L65]()\n\n### 5. Structural Dependencies and Inconsistencies\nThe architecture presents an interesting contradiction: the `TranscriptionService` is designed to be optional (wrapped in `try/except` blocks in `app.py`), yet the primary \"Usage Workflow\" described in the documentation assumes its presence for the \"Paste\" functionality. If the server is down, the core value proposition of the \"retroactive thought capture\" is effectively neutered, leaving the user with just a raw WAV file in `/tmp`.\n\nFurthermore, the `compose.yml` uses environment variables like `${HOME}/LLMOS/` which suggests a highly specific, non-standard host directory structure that a user must manually replicate, or the whole goddamn thing fails to find its models.\n\nSources: [src/omega13/app.py:#L45-L52](), [compose.yml:#L19-L22](), [README.md]()\n\n### Conclusion\nThe Whisper Server Infrastructure is the backbone of Omega-13's utility, transforming raw audio into actionable text. It is structurally isolated via containerization but operationally coupled through a Python-based HTTP client. While the use of CUDA provides necessary performance, the system's reliance on manual container management and specific host paths introduces significant points of failure in an otherwise automated recording workflow.",
      "filePaths": [
        "Containerfile",
        "compose.yml"
      ],
      "importance": "high",
      "relatedPages": [
        "transcription-pipeline"
      ]
    },
    {
      "id": "configuration-guide",
      "title": "Configuration & Customization",
      "content": "<details>\n<summary>Relevant source files</summary>\n\nThe following files were used as context for generating this wiki page:\n- [src/omega13/config.py](https://github.com/b08x/omega-13/blob/main/src/omega13/config.py)\n- [src/omega13/app.py](https://github.com/b08x/omega-13/blob/main/src/omega13/app.py)\n- [src/omega13/audio.py](https://github.com/b08x/omega-13/blob/main/src/omega13/audio.py)\n- [src/omega13/ui.py](https://github.com/b08x/omega-13/blob/main/src/omega13/ui.py)\n- [src/omega13/transcription.py](https://github.com/b08x/omega-13/blob/main/src/omega13/transcription.py)\n- [CHANGELOG.md](https://github.com/b08x/omega-13/blob/main/CHANGELOG.md)\n</details>\n\n# Configuration & Customization\n\n## 1. Introduction\nThe Configuration & Customization system in Omega-13 functions as the central nervous system for state persistence and hardware abstraction. It manages the transition between volatile runtime states (audio buffers, active JACK ports) and persistent disk-based settings. The architecture relies on a `ConfigManager` that enforces a schema for audio routing, transcription parameters, and session management. This mechanism ensures that the application can recover its operational context across restarts, specifically targeting the \"retroactive\" nature of the tool by maintaining pre-configured buffers and hotkeys.\n\n## 2. Configuration Management Architecture\nThe `ConfigManager` class handles the lifecycle of the `config.json` file, located by default in `~/.config/omega13/`. It utilizes a shallow merge strategy to reconcile user-defined overrides with hardcoded system defaults.\n\n### Key Configuration Schemas\nThe system tracks several functional domains:\n*   **Audio Routing:** Persistence of JACK input ports.\n*   **Transcription:** Configuration for the Whisper-server HTTP API, including model size and clipboard behavior.\n*   **Session Logic:** Definition of temporary roots and auto-cleanup policies.\n\n| Field | Type | Default | Description |\n| :--- | :--- | :--- | :--- |\n| `version` | Integer | 2 | Schema versioning. |\n| `global_hotkey` | String | `<ctrl>+<alt>+space` | The trigger for audio capture. |\n| `save_path` | String | `Path.cwd()` | Default directory for exported recordings. |\n| `transcription.server_url` | String | `http://localhost:8080` | Endpoint for the Whisper inference server. |\n| `sessions.auto_cleanup_days` | Integer | 7 | Retention period for temporary session data. |\n\nSources: [src/omega13/config.py:#L24-L65](), [src/omega13/app.py:#L130-L145]()\n\n## 3. Interaction Flow: App Initialization\nThe following diagram illustrates how the `Omega13App` consumes configuration to bootstrap hardware interfaces and UI elements.\n\n```mermaid\nsequenceDiagram\n    participant App as Omega13App\n    participant CM as ConfigManager\n    participant AE as AudioEngine\n    participant UI as TranscriptionDisplay\n\n    App->+CM: __init__()\n    CM-->>-App: Load config.json\n    App->+CM: get_global_hotkey()\n    CM-->>-App: \"<ctrl>+<alt>+space\"\n    App->+AE: __init__(num_channels)\n    Note over AE: Configures JACK ports based on saved state\n    AE-->>-App: Engine Ready\n    App->+UI: Set config_manager\n    UI->+CM: get_copy_to_clipboard()\n    CM-->>-UI: Boolean state\n    UI-->>-App: UI Synchronized\n```\nSources: [src/omega13/app.py:#L125-L160](), [src/omega13/config.py:#L110-L125]()\n\n## 4. Audio & Input Customization\nThe system presents a contradiction between its flexible configuration and its rigid hardware dependencies. While `config.py` allows for `None` input ports, the `AudioEngine` defaults to 2 channels, and the UI forces a choice between Mono and Stereo.\n\n### Input Port Validation\nThe application validates saved ports against the active JACK graph. If the configuration points to ports that no longer exist (e.g., a disconnected hardware interface), the UI enters an \"Invalid config\" state, yet the `AudioEngine` still attempts to initialize with default channel counts\u2014a shitty edge case that can lead to silent recordings if the user doesn't manually intervene.\n\n```python\n# src/omega13/audio.py:#L31-L37\nself.input_ports = []\nfor i in range(num_channels):\n    self.input_ports.append(self.client.inports.register(f\"in_{i+1}\"))\n```\nSources: [src/omega13/audio.py:#L25-L45](), [src/omega13/ui.py:#L100-L130](), [src/omega13/app.py:#L205-L215]()\n\n## 5. Transcription & Notification Settings\nTranscription behavior is governed by the `TranscriptionService`, which depends on the `server_url` defined in the config. A notable structural dependency exists where the `TranscriptionDisplay` widget directly queries the `ConfigManager` to set the initial state of the \"Copy to Clipboard\" checkbox.\n\n*   **Model Selection:** Defaulted to `large-v3-turbo` in `config.py`.\n*   **Clipboard Integration:** Controlled via `copy_to_clipboard` in the transcription sub-dictionary.\n*   **Desktop Notifications:** A global toggle that determines if the `DesktopNotifier` is instantiated during app startup.\n\nSources: [src/omega13/transcription.py:#L35-L55](), [src/omega13/config.py:#L36-L45](), [src/omega13/app.py:#L132-L138]()\n\n## 6. Observed Structural Inconsistencies\nThe configuration logic exhibits a few \"fun\" architectural quirks:\n1.  **Redundant Keys:** In `src/omega13/config.py`, the `save_to_file` key is defined twice in the default dictionary (lines 41-42), suggesting a copy-paste error in the core schema definition.\n2.  **Path Fragility:** The `get_save_path` method defaults to `Path.cwd()` if the configured path does not exist on disk, which can lead to recordings being scattered across various launch directories if the application is invoked from different terminal locations.\n3.  **Cooperative Shutdown:** The `TranscriptionService` implements a `_shutdown_event` and a `_lock`, but the `Omega13App` handles the actual signal registration, creating a tight coupling between the UI lifecycle and the network-bound transcription tasks.\n\nSources: [src/omega13/config.py:#L41-L42](), [src/omega13/config.py:#L100-L108](), [src/omega13/transcription.py:#L56-L60](), [CHANGELOG.md: \"Resolve application hang on exit\"]()\n\n## Conclusion\nConfiguration in Omega-13 is not merely a settings file but a state-management layer that bridges the Textual UI, the JACK audio server, and the Whisper inference engine. Its structural significance lies in its ability to normalize hardware inputs (JACK ports) and external service endpoints (Whisper API) into a unified, persistent environment. However, the reliance on manual validation and the presence of redundant schema keys indicate a system that prioritizes functional flexibility over strict data integrity.",
      "filePaths": [
        "src/omega13/config.py",
        ".claude/settings.local.json"
      ],
      "importance": "medium",
      "relatedPages": [
        "getting-started"
      ]
    }
  ]
}